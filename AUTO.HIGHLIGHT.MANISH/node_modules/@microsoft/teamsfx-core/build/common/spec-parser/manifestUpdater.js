// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRelativePath = exports.generateCommands = exports.updateManifest = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const interfaces_1 = require("./interfaces");
const utils_1 = require("./utils");
const specParserError_1 = require("./specParserError");
const constants_1 = require("./constants");
async function updateManifest(manifestPath, outputSpecPath, adaptiveCardFolder, spec, allowMultipleParameters, auth) {
    var _a, _b;
    try {
        const originalManifest = await fs_extra_1.default.readJSON(manifestPath);
        const updatedPart = {};
        const [commands, warnings] = await generateCommands(spec, adaptiveCardFolder, manifestPath, allowMultipleParameters);
        const composeExtension = {
            composeExtensionType: "apiBased",
            apiSpecificationFile: getRelativePath(manifestPath, outputSpecPath),
            commands: commands,
        };
        if (auth) {
            if (utils_1.isAPIKeyAuth(auth)) {
                auth = auth;
                const safeApiSecretRegistrationId = utils_1.getSafeRegistrationIdEnvName(`${auth.name}_${constants_1.ConstantString.RegistrationIdPostfix}`);
                composeExtension.authorization = {
                    authType: "apiSecretServiceAuth",
                    apiSecretServiceAuthConfiguration: {
                        apiSecretRegistrationId: `\${{${safeApiSecretRegistrationId}}}`,
                    },
                };
            }
            else if (utils_1.isBearerTokenAuth(auth)) {
                composeExtension.authorization = {
                    authType: "microsoftEntra",
                    microsoftEntraConfiguration: {
                        supportsSingleSignOn: true,
                    },
                };
                updatedPart.webApplicationInfo = {
                    id: "${{AAD_APP_CLIENT_ID}}",
                    resource: "api://${{DOMAIN}}/${{AAD_APP_CLIENT_ID}}",
                };
            }
        }
        updatedPart.description = {
            short: spec.info.title.slice(0, constants_1.ConstantString.ShortDescriptionMaxLens),
            full: (_b = ((_a = spec.info.description) !== null && _a !== void 0 ? _a : originalManifest.description.full)) === null || _b === void 0 ? void 0 : _b.slice(0, constants_1.ConstantString.FullDescriptionMaxLens),
        };
        updatedPart.composeExtensions = [composeExtension];
        const updatedManifest = Object.assign(Object.assign({}, originalManifest), updatedPart);
        return [updatedManifest, warnings];
    }
    catch (err) {
        throw new specParserError_1.SpecParserError(err.toString(), interfaces_1.ErrorType.UpdateManifestFailed);
    }
}
exports.updateManifest = updateManifest;
async function generateCommands(spec, adaptiveCardFolder, manifestPath, allowMultipleParameters) {
    const paths = spec.paths;
    const commands = [];
    const warnings = [];
    if (paths) {
        for (const pathUrl in paths) {
            const pathItem = paths[pathUrl];
            if (pathItem) {
                const operations = pathItem;
                // Currently only support GET and POST method
                for (const method in operations) {
                    if (method === constants_1.ConstantString.PostMethod || method === constants_1.ConstantString.GetMethod) {
                        const operationItem = operations[method];
                        if (operationItem) {
                            const [command, warning] = utils_1.parseApiInfo(operationItem, allowMultipleParameters);
                            const adaptiveCardPath = path_1.default.join(adaptiveCardFolder, command.id + ".json");
                            command.apiResponseRenderingTemplateFile = (await fs_extra_1.default.pathExists(adaptiveCardPath))
                                ? getRelativePath(manifestPath, adaptiveCardPath)
                                : "";
                            if (warning) {
                                warnings.push(warning);
                            }
                            commands.push(command);
                        }
                    }
                }
            }
        }
    }
    return [commands, warnings];
}
exports.generateCommands = generateCommands;
function getRelativePath(from, to) {
    const relativePath = path_1.default.relative(path_1.default.dirname(from), to);
    return path_1.default.normalize(relativePath).replace(/\\/g, "/");
}
exports.getRelativePath = getRelativePath;
//# sourceMappingURL=manifestUpdater.js.map